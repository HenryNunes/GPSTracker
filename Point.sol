pragma solidity >=0.4.17 <0.6.0;

//import "https://github.com/Sikorkaio/sikorka/contracts/trigonometry.sol";


contract Point {
    
    int256 private latitude;
    int256 private longitude;
    
    constructor(int256 _latitude, int256 _longitude) public{
        latitude = _latitude;
        longitude = _longitude;
    }
    
    function getLatitude() public view returns(int256){
        return latitude;   
    }
    function getLongitude() public view returns(int256){
        return longitude;   
    }
    
    //function that calculates the distance between 2 points.
    //x = Δλ ⋅ cos φm
    //y = Δφ
    //d = R ⋅ √x² + y²
    function calculateDistance(Point p2) view public returns (uint) 
    {
        //converts to radiands
        int256 _lat1 = toRadiands(latitude);
        int256 _lat2 = toRadiands(p2.getLatitude());
        int256 _log1 = toRadiands(longitude);
        int256 _log2 = toRadiands(p2.getLongitude());
        
        int256 x = (_log2 - _log1 ) * cosineAdjusted( (p2.getLatitude() + latitude )  / 2 ) / 10000; // Multiplication adjustment
        
        //latitude delta 
        int256 y = _lat2 - _lat1;
        
        //emit Track(_lat1,_lat2,_log1, _log2,x,y);
        
        //return sqrt(uint256((x * x / 10000) + (y * y / 10000))) * 63710000 /10000; // Multiplication adjustment;
        return sqrt(uint256((x * x) + (y * y))) * 63710000 /10000; // Multiplication adjustment;
    }
    
    
    //Converts degrees in radiands
    function toRadiands(int256 degree) private pure returns (int256)
    {
        int256 PI = 31415;
        int256 radiands = degree * (PI / 180 ) / 10000;
        return radiands;
    }
    
    //Babylon method
    function sqrt(uint x) private pure returns (uint y) 
    {
        uint z = (x + 1) / 2;
        y = x;
        while (z < y) {
        y = z;
        z = (x / z + z) / 2;
        }
    }
    
        //convert radiands
    function cosineAdjusted(int256 degree) private pure returns (int256)
    {
        int cosine = cos(uint16(rtres(900000, 0, degree, 4096, 0)));
        //int256 cosineAdjusted  = 
        return rtres(32767, -32767, cosine, 10000, -10000); //32767: 1 e -1 em bits da biblioteca
    }
    
    
    
    
    // ###############################################
    // ###############################################
    // ############## External API Used ##############
    // ###############################################
    // ###############################################
    
    
    // Table index into the trigonometric table
    uint constant INDEX_WIDTH = 4;
    // Interpolation between successive entries in the tables
    uint constant INTERP_WIDTH = 8;
    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;
    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
    uint16 constant ANGLES_IN_CYCLE = 16384;
    uint16 constant QUADRANT_HIGH_MASK = 8192;
    uint16 constant QUADRANT_LOW_MASK = 4096;
    uint constant SINE_TABLE_SIZE = 16;

    // constant sine lookup table generated by gen_tables.py
    // We have no other choice but this since constant arrays don't yet exist
    uint8 constant entry_bytes = 2;
    bytes constant sin_table = "\x00\x00\x0c\x8c\x18\xf9\x25\x28\x30\xfb\x3c\x56\x47\x1c\x51\x33\x5a\x82\x62\xf1\x6a\x6d\x70\xe2\x76\x41\x7a\x7c\x7d\x89\x7f\x61\x7f\xff";

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @param _width The width of the bits (in bits) we want to extract
     * @param _offset The offset of the bits (in bits) we want to extract
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {
        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);
    }

    function sin_table_lookup(uint index) pure internal returns (uint16) {
        bytes memory table = sin_table;
        uint offset = (index + 1) * entry_bytes;
        uint16 trigint_value;
        assembly {
            trigint_value := mload(add(table, offset))
        }

        return trigint_value;
    }

    /**
     * Return the sine of an integer approximated angle as a signed 16-bit
     * integer.
     *
     * @param _angle A 14-bit angle. This divides the circle into 16384
     *               angle units, instead of the standard 360 degrees.
     * @return The sine result as a number in the range -32767 to 32767.
     */
    function sin(uint16 _angle) public pure returns (int) {
        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);
        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);

        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;
        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

        if (!is_odd_quadrant) {
            index = SINE_TABLE_SIZE - 1 - index;
        }

        uint x1 = sin_table_lookup(index);
        uint x2 = sin_table_lookup(index + 1);
        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);

        int sine;
        if (is_odd_quadrant) {
            sine = int(x1) + int(approximation);
        } else {
            sine = int(x2) - int(approximation);
        }

        if (is_negative_quadrant) {
            sine *= -1;
        }

        return sine;
    }

    /**
     * Return the cos of an integer approximated angle.
     * It functions just like the sin() method but uses the trigonometric
     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
     */
    function cos(uint16 _angle) public pure returns (int) {
        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {
            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;
        } else {
            _angle += QUADRANT_LOW_MASK;
        }
        return sin(_angle);
    }
    
        //rule of three
    function rtres(int256 _max1, int256 _min1, int256 _value, int256 _max2, int256 _min2) private pure returns (int256)
    {
        assert(_max1 > _min1);
        assert(_max2 > _min2);
        
        int256 max1 = _max1 - _min1;
        int256 max2 = _max2 - _min2;
        int256 value = _value - _min1;
        
        int256 retorno = (value * max2 ) / max1;
        
        return retorno + _min2;
    }
    
    
    
}